const { EventEmitter } = require('events');
const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

class OwnFileStream extends EventEmitter {
    constructor(config) {
        super();

        if (!config.contentFilePath) {
            throw Error('Filename must be set in config object.');
        }

        this.logger = config.logger || process.stdout;
        this.contentFilePath = config.contentFilePath;

        this.encoding = config.encoding || 'utf8';
        this.readable = false;
        
        this.fileDescriptor = null;
        this.destination = null;

        this.init.apply(this);
        this.initEvents.apply(this);
    }
    
    init() {
        let contentFilePathChunks = this.contentFilePath.split('/');
        contentFilePathChunks.pop();
        let contentFileBasePath = path.resolve(contentFilePathChunks.join('/'));
                    
        spawn('mkdir', ['-p', contentFileBasePath])
            .on('exit', () => {
                fs.open(this.contentFilePath, 'a+', (error, fileDescriptor) => {
                    if (error) {
                        this.emit('error', error);
                    }
                    this.fileDescriptor = fileDescriptor;
                    this.resume();
                });
            });
    }

    initEvents() {
        this.logger.write('[INFO] Initialization...\n');

        // Readable 
        this.on('data', this.onData);
        // Readable 
        this.on('end', this.onEnd);
        // Readable 
        this.on('readable', this.onReadable);

        // Writeable 
        this.on('drain', this.onDrain);
        // Writeable 
        this.on('finish', this.onFinish);
        // Writeable 
        this.on('pipe', this.onPipe);
        // Writeable 
        this.on('unpipe', this.onUnpipe);

        // Readable & Writeable 
        this.on('close', this.onClose);
        // Readable & Writeable 
        this.on('error', this.onError);

        // Handling of `ctrl + c` 
        process.on('SIGINT', () => this.emit('close'));

        this.logger.write(`[OK] Initialized.\nData will be piped through a file:\n${this.contentFilePath}\n` );
    }

    // Readable interface implementation
    read(size) {
        return this._read(size);
    }

    _read(size) {
        if (!this.readable) {
            return null;
        }

        return fs.createReadStream(this.contentFilePath).on('data', (chunk) => {
            this.emit('data', chunk);
            
            if (this.destination) {
                this.destination.write(chunk, this.encoding);
            }
        });
    }
    
    resume() {
        this.readable = true;
        this.read();

        return this;
    }
    
    setEncoding(encoding) {
        this.encoding = encoding;

        return this;
    }
    
    pipe(destination) {
        this.destination = destination;
        this.emit('pipe', destination);

        return destination;
    }
    
    unpipe(destination) {
        this.destination = null;
        this.emit('unpipe');

        return this;
    }
    
    // Writable interface implementation
    write(chunk, encoding, callback) {
        return this._write(chunk, encoding, callback);
    }

    _write(chunk, encoding, callback) {
        if (!this.fileDescriptor) {
            this.emit('error', new Error(`File stream does not exist.`))
        }
        
        fs.appendFile(this.contentFilePath, chunk, (error) => {
            if (error) {
                this.emit('error', error);
            }

            this.logger.write('[OK] Data has been written.\n');
            this.read();
            
            if (callback) {
                callback();
            }
        });

        return true;
    }
    
    end(chunk, encoding, callback) {
        this.write(chunk, encoding, () => this.emit('close'));
    }

    // Readable events handlers
    onData(chunk) {
        this.logger.write(`[INFO] Data...\n`);
    }
    
    onEnd() {
        this.logger.write(`[INFO] Ending...\n`);
    }

    onReadable() {
        this.logger.write(`[INFO] Readable...\n`);
    }

    // Writeable events handlers
    onDrain() {
        this.logger.write(`[INFO] Drained...\n`);
    }
    
    onFinish() {
        this.logger.write(`[INFO] Finished...\n`);
    }
    
    onPipe(destination) {
        this.logger.write(`[INFO] Piped...\n`);
    }

    onUnpipe(destination) {
        this.logger.write(`[INFO] Unpiped...\n`);
    }

    // Readable && Writeable events handlers
    onClose() {
        this.logger.write(`[INFO] Closing...\n`);
        
        fs.close(this.fileDescriptor, () => {
            this.logger.write(`[OK] Bye!\n`);
            process.exit();
        });
    }

    onError(error) {
        this.logger.write(`[ERROR] An error has been encountered:\n${error.message}\n`);
        this.emit('close');
        throw new Error(`${error.message}`);
    }
}

module.exports = OwnFileStream;