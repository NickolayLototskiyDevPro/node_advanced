const { EventEmitter } = require('events');
const { spawn } = require('child_process');
const { Readable, Transform } = require('stream');
const fs = require('fs');
const path = require('path');

class OwnGulp extends EventEmitter {
    constructor(config) {
        super();

        if (!config.sourceFolder || !config.targetFolder) {
            throw Error('Source and Target folders must be set in config object.');
        }

        this.logger = config.logger || process.stdout;
        
        this.sourceFolder = config.sourceFolder;
        this.targetFolder = config.targetFolder;
        this.copyright = config.copyright;
        this.fileType = config.fileType;
        
        this.targetFilename = this.getTargetFileName(this.fileType);

        this.on('target-is-ready', () => {
            this.writeStream = fs.createWriteStream(this.targetFilename);

            this.writeStream.on('close', () => {
                this.emit('target-is-served');
            });

            this.serveFiles();
        });

        this.on('target-is-served', () => {
            fs.appendFile(this.targetFilename, this.copyright, () => {
                this.logger.write(`[OK] Files were served to:\n${this.targetFolder}\n`);
            });
        });
    }

    init() {
        this.logger.write(`[INFO] Initializing...\n`);
        
        spawn('rm', ['-r', this.targetFolder])
            .on('exit', () => {
                spawn('mkdir', ['-p', this.targetFolder])
                    .on('exit', () => this.emit('target-is-ready'));
            });
    }

    run() {
        this.logger.write(`[INFO] Running...\n`);
        this.init();
    }

    serveFiles() {
        fs.readdir(this.sourceFolder, (err, files) => {
            if (err) {
                throw err;
            }

            let streams = files
                .filter(file => this.filter(file))
                .map(file => {
                    let filePath = path.resolve([this.sourceFolder, file].join('/'));
                    return fs.createReadStream(filePath);
                });

            if (!streams.length) {
                this.logger.write(`[ERROR] No files found...\n`);
                return;
            }
            
            streams.forEach(stream => {
                this.logger.write(`[INFO] Processing file:\n${stream.path}\n`);
                stream.pipe(this.getTransformerStream()).pipe(this.writeStream);
            });
           
        });
    }
    
    getTransformerStream() {
        return new Transform({
            transform(chunk, encoding, callback) {
                this.push(chunk.toString().replace(/\s{2,}/g,''));
                callback();
            }
        });
    }

    filter(file) {
        return file.split('.').pop() === this.fileType;
    }

    getTargetFileName(fileType) {
        return path.resolve([
            this.targetFolder, 
            `${Math.random().toString().slice(3, 12)}.min.${fileType}`
        ].join('/'));
    }
}

module.exports = OwnGulp;